# 1)
def is_even(value):
    return value % 2 == 0


def is_even_2(value):
    if value < 2:
        return value == 0
    return is_even_2(value - 2)


"""Рекурсивные решения зачастую позволяют уменьшить объем кода (в данном примере оба варианта крайне компактны),
считаются более понятными и удобными. Минусы рекурсии- возможность переполнения стека, затраты памяти и пространства.
Итеративный код не такой краткий, более сложный для понимания( в сложных вопросах), однако нет дополнительных накладных расходов,
увеличения пространства."""


class FIFO:

    def __init__(self):
        self.mass = []

    def app(self, el):
        self.mass.append(el)
        return self.mass

    def rm(self, ):
        if self.mass:
            out = self.mass.pop(0)
        else:
            out = None
        # print(out)
        return out

    def __repr__(self):
        return f'{self.__class__} : {self.mass}'


# test:
a = FIFO()
a.app(5)
a.app(2)
a.app(7)
a.rm()
# print(a)

import collections

q = collections.deque()
# test:
q.append(11)
q.append(7)
q.append(8)
q.popleft()

"""O(1)- для append 
O(n)- для pop (очень много операций в случае большого списка)
При использовании Collections и вставка, и удаление - O(1)"""


# 3)
def srt(obj):
    return sorted(obj)


""" Сортировка Timsort- самый быстрый алгоритм, является гибридным- 
создан на основе сортировки слиянием и вставкой. Этот алгоритм анализирует данные и толmко после этого
выбирfет подходящий подход. Сортировка вставкой работает быстро только с небльшим объемом
данных. Если кол-во эл-ов меньше 64, то запускается сортировка вставкой. Если больше, то ищутся части,
которые строго увеличиваются или уменьшаются(если уменьшаются, то они переворачиваются).
Также используется Minrun. Далее происходит сортировка слиянием.
    Этот вид сортировки является самым быстрым, т. к. используется "умная" комбинация способом сортировки,
c предварительным анализом данных и выбором предпочтительного способа."""

# if __name__ == '__main__':
    # print(is_even_2(10))
